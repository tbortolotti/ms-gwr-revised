---
title: "Complete calibration procedure for PGA"
output: html_notebook
---
Here we are showing the complete procedure to calibrate the model and compute regression coefficients for PGA.
The output results are manually set based on previously obtained results, because of the computational complexity it takes to rerun the whole procedure.
The required libraries are loaded:
```{r message=FALSE, warning=FALSE}
library(sf)
library(raster)
library(ggplot2)
library(rgdal) 
library(GWmodel)
library(cowplot)
library(geosphere)
library(psych)
library(pracma)
library(reshape2)
library(plot3D)
```

The datasets are loaded:
```{r}
dataset = readRDS("italian_data_pga.RData")
source("functions.R")
```

The shapefiles are loaded and modified, in order to remove unused regions (Sardinia, Lampedusa, San Marino boundaries):
```{r}
shape_utm = st_read('confini_ut33.shp')
shape_utm_no_lamp = shape_utm
shape_utm_no_lamp$geometry[[1]][[12]] = NULL

shape_utm_no_sardinia = shape_utm
shape_utm_no_sardinia$geometry[[1]][[3]] = NULL
for (i in 4:10){
  shape_utm_no_sardinia$geometry[[1]][[4]] = NULL
}
for (i in 12:57){
  shape_utm_no_sardinia$geometry[[1]][[5]] = NULL
}
```

Project coordinates of the events to work with UTM33:
```{r}
latitude_ev = dataset$ev_latitude
longitude_ev = dataset$ev_longitude
long_lat_ev = cbind(longitude_ev, latitude_ev)
utm_ev = project(long_lat_ev, "+proj=utm +zone=33 ellps=WGS84") 
utm_ev = as.data.frame(utm_ev)
long_lat_ev = as.data.frame(long_lat_ev)
```

Arrange coordinates of the stations to work with UTM33:
```{r}
latitude_st = dataset$st_latitude
longitude_st = dataset$st_longitude
long_lat_st = cbind(longitude_st, latitude_st)
utm_st = project(long_lat_st, "+proj=utm +zone=33 ellps=WGS84") 
utm_st = as.data.frame(utm_st)
long_lat_st = as.data.frame(long_lat_st)
```

Build spatial points data frame for UTM33 coordinates:
```{r}
utm_ev_sp = SpatialPointsDataFrame(utm_ev, dataset[,1:6])
utm_st_sp = SpatialPointsDataFrame(utm_st, dataset[,1:6])
```

Transform shapefile into spatial dataframe:
```{r}
shape_utm_spatial = as_Spatial(shape_utm_no_sardinia)
grid_utm = makegrid(shape_utm_spatial, cellsize = 10000) # cellsize in map units!
grid_utm = SpatialPoints(grid_utm, proj4string = CRS(proj4string(shape_utm_spatial)))
grid_inside_utm = grid_utm[shape_utm_spatial,]
coords_utm = grid_inside_utm@coords
coords_df_utm = as.data.frame(coords_utm)
```

Apply functional on dataset, set parameters and create covariate matrices:
```{r}
mh = 5.5
mref = 5.324
h = 6.924
attach(dataset)
b1 = (mag-mh)*(mag<=mh)
b2 = (mag-mh)*(mag>mh)
c1 = (mag-mref)*log10(sqrt(JB_complete^2+h^2))
c2 = log10(sqrt(JB_complete^2+h^2))
c3 = sqrt(JB_complete^2+h^2)
f1 = as.numeric(fm_type_code == "SS")
f2 = as.numeric(fm_type_code == "TF")
k = log10(vs30/800)*(vs30<=1500)+log10(1500/800)*(vs30>1500)
y = log10(rotD50_pga)
detach(dataset)

Xc = cbind(b1,b2,f1,f2,c1)
Xe = cbind(c2,c3)
Xs = k
```

The best bandwidth is selected:
```{r eval = FALSE}
bwe_tot = c(10000, 25000, 50000, 75000, 100000)
bws_tot = c(10000, 25000, 50000, 75000, 100000)
n_bwe = length(bwe_tot)
n_bws = length(bws_tot)
bw_table = matrix(0, n_bwe, n_bws)
row.names(bw_table) = bwe_tot 
colnames(bw_table) = bws_tot 

for (i in 1:n_bwe){
  for (j in 1:n_bws){
    bandwidth = gcv_mei_only_one(i,j,SEC_only_calibration, Xc, Xe, Xs, y, "c", coordinates(utm_ev_sp),
                                 coordinates(utm_st_sp))
    bw_table[i,j] = bandwidth$gcv
  }
}

bw_best = which(bw_table == max(bw_table), arr.ind = T)
bwe = bwe_tot[bw_best[1]]
bws = bws_tot[bw_best[2]]
```
```{r echo=FALSE}
bwe = 25000
bws = 75000
bwe
bws
```
Compare ordinary least squares with completely varying model, in order to justify the introduction o f spatial non-stationarity
```{r eval = FALSE}
#OLS vs completely varying (take R(H1) from here for all stationarity tests)
ols = lm(y ~ Xc + Xe + Xs)
only_intercept = SEC_only_constant_intercept_calibration(Xe, cbind(Xc, Xs), y,
                                                         bwe, bws, coordinates(utm_ev_sp),
                                                         coordinates(utm_st_sp))
n_sample = length(y)
#compute R(H0)
X = cbind(rep(1,n_sample), Xc, Xe, Xs)
I = diag(1,n_sample)
Hols = X%*%(solve(t(X)%*%X))%*%t(X)
RH0 = t(I-Hols)%*%(I-Hols)
epsilon = (I-Hols)%*%y
#compute R(H1)
B = only_intercept$B
Xcc = rep(1,n_sample)
H1 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH1 = t(I-H1)%*%(I-H1) #use this RH1 for all the following stationarity tests, 
                       #it can be saved as "RH1_only_intercept_rotD50pga.RData" to be reloaded later
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = Hols %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_ols = sum(t_stat>as.numeric(T0))/n_perm
```

```{r echo=FALSE}
p_ols = 0.000
p_ols
```
Now we check the stationarity of all parameters, using SEC and one at a time:
```{r eval = FALSE}
#check if b1 is stationary (if dependency is not known, it is set as site-dependent)
Xc = b1
Xe = cbind(c2,c3)
Xs = cbind(b2,f1,f2,c1,k)
sec = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
#compute R(H0)
I= diag(1,n_sample)
B = sec$B
Xcc = cbind(rep(1,n_sample), Xc)
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH0 = t(I-H0)%*%(I-H0)
epsilon= (I-H0)%*%y
#load R(H1)
RH1 = readRDS("RH1_only_intercept_rotD50pga.RData")
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_b1 = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_b1 = 0.988
p_b1
```
```{r}

```
```{r eval = FALSE}
#check if b2 is stationary
Xc = b2
Xe = cbind(c2,c3)
Xs = cbind(b1,f1,f2,c1,k)
sec = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
#compute R(H0)
I= diag(1,n_sample)
B = sec$B
Xcc = cbind(rep(1,n_sample), Xc)
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH0 = t(I-H0)%*%(I-H0)
epsilon= (I-H0)%*%y
#load R(H1)
RH1 = readRDS("RH1_only_intercept_rotD50pga.RData")
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_b2 = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_b2 = 0.116
p_b2
```

```{r eval = FALSE}
#check if f1 is stationary
Xc = f1
Xe = cbind(c2,c3)
Xs = cbind(b1,b2,f2,c1,k)
sec = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
#compute R(H0)
I= diag(1,n_sample)
B = sec$B
Xcc = cbind(rep(1,n_sample), Xc)
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH0 = t(I-H0)%*%(I-H0)
epsilon= (I-H0)%*%y
#load R(H1)
RH1 = readRDS("RH1_only_intercept_rotD50pga.RData")
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_f1 = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_f1 = 0.972
p_f1
```

```{r eval = FALSE}
#check if f2 is stationary
Xc = f2
Xe = cbind(c2,c3)
Xs = cbind(b1,b2,f1,c1,k)
sec = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))

#compute R(H0)
I= diag(1,n_sample)
B = sec$B
Xcc = cbind(rep(1,n_sample), Xc)
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH0 = t(I-H0)%*%(I-H0)
epsilon= (I-H0)%*%y
#load R(H1)
RH1 = readRDS("RH1_only_intercept_rotD50pga.RData")
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_f2 = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_f2 = 0.033
p_f2
```

```{r eval = FALSE}
#check if c1 is stationary
Xc = c1
Xe = cbind(c2,c3)
Xs = cbind(b1,b2,f1,f2,k)
sec = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
#compute R(H0)
I= diag(1,n_sample)
B = sec$B
Xcc = cbind(rep(1,n_sample), Xc)
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH0 = t(I-H0)%*%(I-H0)
epsilon= (I-H0)%*%y
#load R(H1)
RH1 = readRDS("RH1_only_intercept_rotD50pga.RData")
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_c1 = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_c1 = 0.156
p_c1
```

```{r eval = FALSE}
#check if c2 is stationary
Xc = c2
Xe = c3
Xs = cbind(b1,b2,f1,f2,c1,k)
sec = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
#compute R(H0)
I= diag(1,n_sample)
B = sec$B
Xcc = cbind(rep(1,n_sample), Xc)
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH0 = t(I-H0)%*%(I-H0)
epsilon= (I-H0)%*%y
#load R(H1)
RH1 = readRDS("RH1_only_intercept_rotD50pga.RData")
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)

#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_c2 = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_c2 = 0.047
p_c2
```

```{r eval = FALSE}
#check if c3 is stationary
Xc = c3
Xe = c2
Xs = cbind(b1,b2,f1,f2,c1,k)
sec = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
#compute R(H0)
I= diag(1,n_sample)
B = sec$B
Xcc = cbind(rep(1,n_sample), Xc)
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH0 = t(I-H0)%*%(I-H0)
epsilon= (I-H0)%*%y
#load R(H1)
RH1 = readRDS("RH1_only_intercept_rotD50pga.RData")
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_c3 = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_c3 = 0.012
p_c3
```

```{r eval = FALSE}
#check if k is stationary
Xc = k
Xe = cbind(c2,c3)
Xs = cbind(b1,b2,f1,f2,c1)
sec = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
#compute R(H0)
I= diag(1,n_sample)
B = sec$B
Xcc = cbind(rep(1,n_sample), Xc)
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH0 = t(I-H0)%*%(I-H0)
epsilon= (I-H0)%*%y
#load R(H1)
RH1 = readRDS("RH1_only_intercept_rotD50pga.RData")
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_k = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_k = 0.087
p_k
```

The previous results and our previous knowledge from literature are verified jointly:
```{r eval = FALSE}
#check jointly if they are stationary
Xc = cbind(b1,b2,f1,f2,c1)
Xe = cbind(c2,c3)
Xs = k
ols = lm(y ~ Xc + Xe + Xs)
sec = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
#compute R(H0)
X = cbind(rep(1,n_sample), Xc, Xe, Xs)
I = diag(1,n_sample)
Hols = X%*%(solve(t(X)%*%X))%*%t(X)
RH0 = t(I-Hols)%*%(I-Hols)
epsilon = (I-Hols)%*%y
#compute R(H1)
I= diag(1,n_sample)
B = sec$B
Xcc = cbind(rep(1,n_sample), Xc)
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH1 = t(I-H0)%*%(I-H0) #it can be saved as "RH1_stationary_rotD50pga.RData" to be reloaded for the following tests
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_cumulative_stationary = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_cumulative_stationary = 0.078
p_cumulative_stationary
```
Now we have to check if the stationary coefficients are significant or if they can be considered as 0, at first one at a time. They are not checked jointly since all of them are kept, in order to be able to have a direct comparison with ITA18.

```{r eval = FALSE}
#check if the intercept is null (as R(H1) take R(H1) from previous point)
Xc = cbind(b1,b2,f1,f2,c1)
Xe = cbind(c2,c3)
Xs = k
sec_null = SEC_no_intercept_calibration(Xc, Xe, Xs, y, bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
sec = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
#compute R(H0)
I= diag(1,n_sample)
B = sec_null$B
Xcc = Xc
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH0 = t(I-H0)%*%(I-H0)
epsilon= (I-H0)%*%y
#load R(H1)
RH1 = readRDS("RH1_stationary_rotD50pga.RData")
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_a_null = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_a_null = 0.000
p_a_null
```

```{r eval = FALSE}
#check if b1 is null
Xc = cbind(b2,f1,f2,c1)
Xe = cbind(c2,c3)
Xs = k
sec_null = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
#compute R(H0)
I= diag(1,n_sample)
B = sec_null$B
Xcc = cbind(rep(1,n_sample), Xc)
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH0 = t(I-H0)%*%(I-H0)
epsilon= (I-H0)%*%y
#load R(H1)
RH1 = readRDS("RH1_stationary_rotD50pga.RData")
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_b1_null = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_b1_null = 0.000
p_b1_null
```

```{r eval = FALSE}
#check if b2 is null
Xc = cbind(b1,f1,f2,c1)
Xe = cbind(c2,c3)
Xs = k
sec_null = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
#compute R(H0)
I= diag(1,n_sample)
B = sec_null$B
Xcc = cbind(rep(1,n_sample), Xc)
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH0 = t(I-H0)%*%(I-H0)
epsilon= (I-H0)%*%y
#load R(H1)
RH1 = readRDS("RH1_stationary_rotD50pga.RData")
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_b2_null = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_b2_null = 0.151
p_b2_null
```

```{r eval = FALSE}
#check if f1 is null
Xc = cbind(b1,b2,f2,c1)
Xe = cbind(c2,c3)
Xs = k
sec_null = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
#compute R(H0)
I= diag(1,n_sample)
B = sec_null$B
Xcc = cbind(rep(1,n_sample), Xc)
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH0 = t(I-H0)%*%(I-H0)
epsilon= (I-H0)%*%y
#load R(H1)
RH1 = readRDS("RH1_stationary_rotD50pga.RData")
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_f1_null = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_f1_null = 0.031
p_f1_null
```

```{r eval = FALSE}
#check if f2 is null
Xc = cbind(b1,b2,f1,c1)
Xe = cbind(c2,c3)
Xs = k
sec_null = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
#compute R(H0)
I= diag(1,n_sample)
B = sec_null$B
Xcc = cbind(rep(1,n_sample), Xc)
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH0 = t(I-H0)%*%(I-H0)
epsilon= (I-H0)%*%y
#load R(H1)
RH1 = readRDS("RH1_stationary_rotD50pga.RData")
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_f2_null = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_f2_null = 0.117
p_f2_null
```

```{r eval = FALSE}
#check if c1 is null
Xc = cbind(b1,b2,f1,f2)
Xe = cbind(c2,c3)
Xs = k
sec_null = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
#compute R(H0)
I= diag(1,n_sample)
B = sec_null$B
Xcc = cbind(rep(1,n_sample), Xc)
H0 = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B
RH0 = t(I-H0)%*%(I-H0)
epsilon= (I-H0)%*%y
#load R(H1)
RH1 = readRDS("RH1_stationary_rotD50pga.RData")
#compute T
T0 = (t(y) %*% (RH0-RH1) %*% y) / (t(y) %*% RH1 %*% y)
#permutations
n_perm = 1000
t_stat = rep(0,n_perm)
for (i in 1:n_perm){
  eps_star = sample(epsilon)
  y_star = H0 %*% y + eps_star
  t_stat[i] = (t(y_star) %*% (RH0-RH1) %*% y_star) / (t(y_star) %*% RH1 %*% y_star)
}
p_c1_null = sum(t_stat>as.numeric(T0))/n_perm
```
```{r echo=FALSE}
p_c1_null = 0.000
p_c1_null
```
Now we have to compare the GCV values obtained using SEC and ESC, leading to the selection of SEC
```{r eval = FALSE}
Xc = cbind(b1,b2,f1,f2,c1)
Xe = cbind(c2,c3)
Xs = k
gcv_mei_only_one(bwe,bws,ESC_only_calibration, Xc, Xe, Xs, y, "c", coordinates(utm_ev_sp),
                 coordinates(utm_st_sp)) #compare this GCV with the one obtained in bandwidth selection
```
The next step is to compute $R^2_{adj}$
```{r eval = FALSE}
Xc = cbind(b1,b2,f1,f2,c1)
Xe = cbind(c2,c3)
Xs = k
sec = SEC_only_calibration(Xc, Xe, Xs, y, "c", bwe, bws, coordinates(utm_ev_sp), coordinates(utm_st_sp))
n_sample = length(y)
I= diag(1,n_sample)
B = sec$B
Xcc = cbind(rep(1,n_sample), Xc)
H = I - B + B %*% Xcc %*% solve(t(Xcc)%*%t(B)%*%B%*%Xcc) %*% t(Xcc) %*% t(B)%*% B #this can be saved as                                                                                      #"H_hat_pga.RData"
epsilon= (I-H)%*%y
delta1 = n_sample-2*tr(H)+tr(t(H)%*%H) #this can be saved as "delta1_pga.RData"
delta2 = tr((t(I-H)%*%(I-H)) %*% (t(I-H)%*%(I-H))) #this can be saved as "delta1_pga.RData"
rss = sum(epsilon^2)
sigma2hat = rss/delta1
tss = sum((H%*%y-mean(y))^2)
sqrt(sigma2hat)
R2 = 1-rss/tss
R2adj = 1-(1-R2)*(n_sample-1)/delta1
```
```{r echo=FALSE}
R2adj = 0.8780
R2adj
```
Now we can compute all the regression coefficients:
```{r eval = FALSE}
result = SEC_grid_creation(Xc, Xe, Xs, y,"c", bwe, bws, coordinates(utm_ev_sp),
                           coordinates(utm_st_sp), coords_utm, sec)
beta_const = result$beta_c

beta_k = t(result$beta_s)
beta_k_coord = cbind(coords_utm, beta_k)
beta_k_coord = as.data.frame(beta_k_coord)

beta_c2 = result$beta_e[1,]
beta_c2_coord = cbind(coords_utm, beta_c2)
beta_c2_coord = as.data.frame(beta_c2_coord)

beta_c3 = result$beta_e[2,]
beta_c3_coord = cbind(coords_utm, beta_c3)
beta_c3_coord = as.data.frame(beta_c3_coord)
```
```{r echo=FALSE}
beta_const
```

The non-stationary regression coefficients can be plotted:
```{r}
ggplot() + 
  geom_tile(beta_k_coord, mapping = aes(x=x1, y=x2, fill=beta_k))+
  scale_fill_gradientn(colours = c("darkblue", "dodgerblue1", "cadetblue2", "white"), name = "k"
                       ,limits = c(-1,0), breaks = c(-1, -0.5,0)
  )+
  geom_sf(data = shape_utm_no_lamp, size = 1.6, color = "black", fill = NA )+
  geom_point(data = utm_st, aes(x=longitude_st, y=latitude_st), fill= 'firebrick3',
             size = 1, shape = 21, stroke = 0.7)+
  theme(axis.text=element_text(size=15, colour = "black"),
        axis.title=element_blank(),
        legend.text=element_text(size=20, colour = "black"),
        plot.title = element_blank(),
        axis.ticks=element_blank(),
        legend.title = element_text(size=20, colour = "black"),
        panel.background = element_rect(fill = "lightcyan2", colour = "skyblue3",
                                        size = 2, linetype = "solid"),
        panel.grid = element_line(size = 0.25, linetype = 'solid',
                                  colour = "aliceblue")
  )

```


```{r}
ggplot() + 
  geom_tile(beta_c2_coord, mapping = aes(x=x1, y=x2, fill=beta_c2))+
  #coord_sf()+
  scale_fill_gradientn(colours = c("darkblue", "dodgerblue1", "cadetblue2", "white")
                       , name = expression(paste(c[2]))
                       ,limits = c(-1.8, -1), breaks = c(-1.8, -1.4, -1),
                       labels = c(-1.8, -1.4, -1))+
  geom_sf(data = shape_utm_no_lamp, size = 1.6, color = "black", fill = NA)+
  geom_point(data = utm_ev, aes(x=longitude_ev, y=latitude_ev), fill= 'firebrick3',
             size = 3, shape = 21, stroke = 1.5)+
  theme(axis.text=element_text(size=15, colour = "black"),
        axis.title=element_blank(),
        legend.text=element_text(size=20, colour = "black"),
        plot.title = element_blank(),
        axis.ticks=element_blank(),
        legend.title = element_text(size=20, colour = "black"),
        panel.background = element_rect(fill = "lightcyan2", colour = "skyblue3",
                                        size = 2, linetype = "solid"),
        panel.grid = element_line(size = 0.25, linetype = 'solid',
                                  colour = "aliceblue")
  )
```


```{r}
beta_c3_bis = beta_c3
beta_c3_bis[beta_c3_bis<(-0.009)]=-0.009
beta_c3_coord = cbind(coords_utm, beta_c3)
beta_c3_coord = as.data.frame(beta_c3_coord)
beta_c3_bis_coord = cbind(coords_utm, beta_c3_bis)
beta_c3_bis_coord = as.data.frame(beta_c3_bis_coord)

ggplot() + 
  geom_tile(beta_c3_bis_coord, mapping = aes(x=x1, y=x2, fill=beta_c3_bis))+
  scale_fill_gradientn(colours = c("darkblue", "dodgerblue1", "cadetblue2", "white")
                       , name = expression(paste(c[3]))
                       ,limits = c(-0.009, 0.003), breaks = c(-0.009, -0.006, -0.003, 0, 0.003),
                       labels = c("<-0.009", -0.006, -0.003, 0, 0.003))+
  geom_sf(data = shape_utm_no_lamp, size = 1.6, color = "black", fill = NA)+
  geom_point(data = utm_ev, aes(x=longitude_ev, y=latitude_ev), fill= 'firebrick3',
             size = 3, shape = 21, stroke = 1.5)+
  theme(axis.text=element_text(size=15, colour = "black"),
        axis.title=element_blank(),
        legend.text=element_text(size=20, colour = "black"),
        plot.title = element_blank(),
        axis.ticks=element_blank(),
        legend.title = element_text(size=20, colour = "black"),
        panel.background = element_rect(fill = "lightcyan2", colour = "skyblue3",
                                        size = 2, linetype = "solid"),
        panel.grid = element_line(size = 0.25, linetype = 'solid',
                                  colour = "aliceblue")
  )
```
The calibration procedure is complete, with the obtained results and using the other functions contained in the functions file we can predict, evaluate and use the obtained GMPE.