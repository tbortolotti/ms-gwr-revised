data2 <- dt_2[-indexes.deep,]
names(data2)[3] <- 'time'
fit <- survfit(Surv(time, status==2) ~ 1, data = data2)
## Kaplan Meier curve plot
x11()
ggsurvplot(fit,
risk.table = TRUE, # Add risk table
risk.table.col = "strata", # Change risk table color by groups
surv.median.line = "hv", # Specify median survival
ggtheme = theme_bw(), # Change ggplot2 theme
break.time.by=90,
title="Kaplan-Meier Curve for 40% deepest points")
fac <- rep(0,200)
fac <- rep(2,200)
fac[indexes.deep] <- 1
fac <- as.factor(fac)
is(fac)
new.data <- data.frame(dt_2,fac)
names(new.data)
test <- survdiff(Surv(time, status) ~ fac, data = new.data)
names(new.data)[3] <- 'time'
test <- survdiff(Surv(time, status) ~ fac, data = new.data)
test
# Point 3
mod.cox <- coxph(Surv(time, status) ~ RFA + APC + fac, data =  new.data)
summary(mod.cox)
cont_df <- data.frame(RFA = med1[1], APC = med1[2],fac=1)
cont_df
cont.age <- survfit(mod.cox, newdata = cont_df)
cont_df <- with(new.data,
data.frame(RFA = med1[1],
APC = med1[2],
fac = 1))
cont_df
cont.age <- survfit(mod.cox, newdata = cont_df)
cont_df <- with(new.data,data.frame(RFA = med1[1],APC = med1[2],fac = 1))
cont_df
cont.age <- survfit(mod.cox, newdata = cont_df)
cont.age
# Point 3
# I need to evaluate the confidence interval for a student of
#the first group
new.data1 <- new.data[indexes.deep,]
mod.cox <- coxph(Surv(time, status) ~ RFA + APC, data =  new.data1)
cont_df <- with(new.data,data.frame(RFA = med1[1],APC = med1[2]))
cont_df
cont.age <- survfit(mod.cox, newdata = cont_df)
cont.age
new.data2 <- new.data[-indexes.deep,]
mod.cox <- coxph(Surv(time, status) ~ RFA + APC, data =  new.data2)
cont_df <- with(new.data,data.frame(RFA = med2[1],APC = med2[2]))
cont_df
cont.age <- survfit(mod.cox, newdata = cont_df)
cont.age
setwd("C:/Users/Teresa Bortolotti/Desktop/NonParametric/MyCodes")
rm(list=ls())
cat('\014')
# ~
load('votesold.rda')
data <- as.matrix(dt_2[,1:2])
n <- dim(data)[1]
dep <- numeric(n)
for(i in 1:n)
{
point <- c(data[i,1],data[i,2])
dep[i] <- depth(point,data,method='Tukey')
}
# non capisco perchÃ© mahalanobis non funzioni
q.d <- quantile(dep,0.4)
indexes.deep <- which(dep<=q.d)
data1 <- data[indexes.deep,]
data2 <- data[-indexes.deep,]
#
x1 <- data1
x2 <- data2
med1 <- depthMedian(data1,depth_params = list(method='Mahalanobis')) # default=Tukey (halfspace)
med2 <- depthMedian(data2,depth_params = list(method='Mahalanobis'))
n1 <- dim(x1)[1]
n2 <- dim(x2)[1]
n  <- n1 + n2
T0 <- (med1[1]-med2[1])^2+(med1[2]-med2[2])^2
B <- 1000
set.seed(1991)
T_stat <- numeric(B)
for(perm in 1:B){
# Random permutation of indexes
# When we apply permutations in a multivariate case, we keep the units together
# i.e., we only permute the rows of the data matrix
x_pooled <- rbind(x1,x2)
permutation <- sample(n)
x_perm <- x_pooled[permutation,]
x1_perm <- x_perm[1:n1,]
x2_perm <- x_perm[(n1+1):n,]
# Evaluation of the test statistic on permuted data
x1.med_perm <- depthMedian(x1_perm,depth_params = list(method='Mahalanobis'))
x2.med_perm <- depthMedian(x2_perm,depth_params = list(method='Mahalanobis'))
T_stat[perm] <- (x1.med_perm[1]-x2.med_perm[1])^2+(x1.med_perm[2]-x2.med_perm[2])^2
}
# Permutational distribution of T2
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30)
abline(v=T0,col=3,lwd=2)
x11()
plot(ecdf(T_stat))
abline(v=T0,col=3,lwd=2)
# p-value
p_val <- sum(T_stat>=T0)/B
p_val
data1 <- dt_2[indexes.deep,]
names(data1)[3] <- 'time'
fit <- survfit(Surv(time, status==2) ~ 1, data = data1)
## Kaplan Meier curve plot
x11()
ggsurvplot(fit,
risk.table = TRUE, # Add risk table
risk.table.col = "strata", # Change risk table color by groups
surv.median.line = "hv", # Specify median survival
ggtheme = theme_bw(), # Change ggplot2 theme
break.time.by=90,
title="Kaplan-Meier Curve for 40% deepest points")
#0.6 deepest
data2 <- dt_2[-indexes.deep,]
names(data2)[3] <- 'time'
fit <- survfit(Surv(time, status==2) ~ 1, data = data2)
## Kaplan Meier curve plot
x11()
ggsurvplot(fit,
risk.table = TRUE, # Add risk table
risk.table.col = "strata", # Change risk table color by groups
surv.median.line = "hv", # Specify median survival
ggtheme = theme_bw(), # Change ggplot2 theme
break.time.by=90,
title="Kaplan-Meier Curve for 40% deepest points")
# create a new dataset with a column that is a factor
# 1 --> point belongs to 40% deepest group
# 2 --> otherwise
fac <- rep(2,200)
fac[indexes.deep] <- 1
fac <- as.factor(fac)
new.data <- data.frame(dt_2,fac)
names(new.data)[3] <- 'time'
test <- survdiff(Surv(time, status) ~ fac, data = new.data)
test
new.data1 <- new.data[indexes.deep,]
mod.cox <- coxph(Surv(time, status) ~ RFA + APC, data =  new.data1)
cont_df <- with(new.data,data.frame(RFA = med1[1],APC = med1[2]))
cont_df
cont.age <- survfit(mod.cox, newdata = cont_df)
cont.age
new.data2 <- new.data[-indexes.deep,]
mod.cox <- coxph(Surv(time, status) ~ RFA + APC, data =  new.data2)
cont_df <- with(new.data,data.frame(RFA = med2[1],APC = med2[2]))
cont_df
cont.age <- survfit(mod.cox, newdata = cont_df)
cont.age
rm(list=ls())
cat('\014')
load('ex1.rda')
# Point 1
delta.0 <- seq(-5,5,by=0.1)
head(delta.0)
x1 <- votes.post
x2 <- votes.pre
# Parameters:
n1 <- length(x1)
n2 <- length(x2)
n <- n1 + n2
x_pooled <- c(x1,x2)
n.test <- length(delta.0)
pval.vec <- numeric(n.test)
B <- 1000
for(i in 1:n.test)
{
T0 <- mean(x1) - mean(x2) - delta.0[i]
set.seed(1991)
T_stat <- numeric(B)
for(perm in 1:B){
permutation <- sample(1:n)
x_perm <- x_pooled[permutation]
x1_perm <- x_perm[1:n1]
x2_perm <- x_perm[(n1+1):n]
# test statistic:
T_stat[perm] <- mean(x1_perm) - mean(x2_perm) - delta.0[i]
}
# p-value
pval.vec[i] <- sum(T_stat>=T0)/B
}
delta <- -2
T0 <- mean(x1) - mean(x2) - delta
set.seed(1991)
T_stat <- numeric(B)
for(perm in 1:B){
permutation <- sample(1:n)
x_perm <- x_pooled[permutation]
x1_perm <- x_perm[1:n1]
x2_perm <- x_perm[(n1+1):n]
# test statistic:
T_stat[perm] <- mean(x1_perm) - mean(x2_perm) - delta
}
# p-value
pval <- sum(T_stat>=T0)/B
permut <- sample(1:n)
permut
permut <- sample(1:n)
permut
delta.0 <- seq(-5,5,by=0.1)
x1 <- votes.post
x2 <- votes.pre
# Parameters:
n1 <- length(x1)
n2 <- length(x2)
n <- n1 + n2
x_pooled <- c(x1,x2)
n.test <- length(delta.0)
pval.vec <- numeric(n.test)
B <- 1000
for(i in 1:n.test)
{
T0 <- abs(mean(x1) - mean(x2) - delta.0[i])
set.seed(1991)
T_stat <- numeric(B)
for(perm in 1:B){
permutation <- sample(1:n)
x_perm <- x_pooled[permutation]
x1_perm <- x_perm[1:n1]
x2_perm <- x_perm[(n1+1):n]
# test statistic:
T_stat[perm] <- abs(mean(x1_perm) - mean(x2_perm) - delta.0[i])
}
# p-value
pval.vec[i] <- sum(T_stat>=T0)/B
}
x11()
plot(pval.vec)
x11()
plot(delta.0,pval.vec)
# Point 3
alpha <- seq(0.05,0.95,by=0.05)
x1 <- votes.post
x2 <- votes.pre
quantile(x1,1-alpha[1])
# Point 3
alpha.0 <- seq(0.05,0.95,by=0.05)
x1 <- votes.post
x2 <- votes.pre
# Parameters:
n1 <- length(x1)
n2 <- length(x2)
n <- n1 + n2
x_pooled <- c(x1,x2)
n.test <- length(alpha.0)
pval.vec <- numeric(n.test)
B <- 1000
for(i in 1:n.test)
{
T0 <- abs(quantile(x1, 1-alpha[i]) - quantile(x2,1-alpha[i]))
set.seed(1991)
T_stat <- numeric(B)
for(perm in 1:B){
permutation <- sample(1:n)
x_perm <- x_pooled[permutation]
x1_perm <- x_perm[1:n1]
x2_perm <- x_perm[(n1+1):n]
# test statistic:
T_stat[perm] <- abs(quantile(x1_perm, 1-alpha[i]) - quantile(x2_perm,1-alpha[i]))
}
# p-value
pval.vec[i] <- sum(T_stat>=T0)/B
}
x11()
plot(alpha.0,pval.vec)
plot(alpha.0,pval.vec, type='l')
x11()
plot(alpha.0,pval.vec, type='l', lwd=3)
# Point 2
rejectH0 <- delta.0[which(pval.vec<=0.05)]
range(rejectH0)
mean(x1)
mean(x2)
depth(point[1],data[,1],method='Mahalanobis')
setwd("C:/Users/Teresa Bortolotti/Desktop/NonParametric/MyCodes")
rm(list=ls())
cat('\014')
# ~
load('votesold.rda')
data <- as.matrix(dt_2[,1:2])
n <- dim(data)[1]
dep <- numeric(n)
for(i in 1:n)
{
point <- c(data[i,1],data[i,2])
dep[i] <- depth(point,data,method='Tukey')
}
depth(point[1],data[,1],method='Mahalanobis')
depth(c(0,0),data,method='Mahalanobis')
load('ex1.rda')
# Point 1
delta.0 <- seq(-5,5,by=0.1)
x1 <- votes.post
x2 <- votes.pre
# Parameters:
n1 <- length(x1)
n2 <- length(x2)
n <- n1 + n2
x_pooled <- c(x1,x2)
n.test <- length(delta.0)
pval.vec <- numeric(n.test)
B <- 1000
for(i in 1:n.test)
{
T0 <- abs(mean(x1) - mean(x2) - delta.0[i])
set.seed(1991)
T_stat <- numeric(B)
for(perm in 1:B){
permutation <- sample(1:n)
x_perm <- x_pooled[permutation]
x1_perm <- x_perm[1:n1]
x2_perm <- x_perm[(n1+1):n]
# test statistic:
T_stat[perm] <- abs(mean(x1_perm) - mean(x2_perm) - delta.0[i])
}
# p-value
pval.vec[i] <- sum(T_stat>=T0)/B
}
x11()
plot(delta.0,pval.vec, type='l', lwd=3)
B <- 1000
T0 <- abs(mean(x1) - mean(x2))
set.seed(1991)
T_stat <- numeric(B)
for(perm in 1:B){
permutation <- sample(1:n)
x_perm <- x_pooled[permutation]
x1_perm <- x_perm[1:n1]
x2_perm <- x_perm[(n1+1):n]
# test statistic:
T_stat[perm] <- abs(mean(x1_perm) - mean(x2_perm))
}
# p-value
p_val <- sum(T_stat>=T0)/B
p_val
alpha.0 <- seq(0.05,0.95,by=0.05)
x1 <- votes.post
x2 <- votes.pre
# Parameters:
n1 <- length(x1)
n2 <- length(x2)
n <- n1 + n2
x_pooled <- c(x1,x2)
n.test <- length(alpha.0)
pval.vec <- numeric(n.test)
B <- 1000
for(i in 1:n.test)
{
T0 <- abs(quantile(x1, 1-alpha.0[i]) - quantile(x2,1-alpha.0[i]))
set.seed(1991)
T_stat <- numeric(B)
for(perm in 1:B){
permutation <- sample(1:n)
x_perm <- x_pooled[permutation]
x1_perm <- x_perm[1:n1]
x2_perm <- x_perm[(n1+1):n]
# test statistic:
T_stat[perm] <- abs(quantile(x1_perm, 1-alpha.0[i]) - quantile(x2_perm,1-alpha.0[i]))
}
# p-value
pval.vec[i] <- sum(T_stat>=T0)/B
}
x11()
plot(alpha.0,pval.vec, type='l', lwd=3)
getwd()
# Change working directory
setwd("C:/Users/Teresa Bortolotti/Documents/R/ms-gwr-reviewed")
#The required libraries are loaded----
library(plot3D)
library(GWmodel)
library(psych)
library(ggplot2)
library(reshape2)
#The required functions are loaded----
source("functions.R")
inf = -5
sup = 5
step = 0.5
x = s1 = s2 = e1 = e2 = seq(inf, sup, by = step)
adj = (length(x)+1)/2
grid_e_sim = matrix(0,(length(e1)*length(e2)),2)
dim(grid)
for (i in 1:length(e1)){
for (j in 1:length(e2)){
grid_e_sim[j+(i-1)*length(s2),] = c(e1[i],e2[j])
}
}
dim(grid_e_sim)
# grid_s_sim is a 441x2 matrix, that for every location saves its site coordinates
grid_s_sim = matrix(0,(length(s1)*length(s2)),2)
dim(grid_s_sim)
for (i in 1:length(s1)){
for (j in 1:length(s2)){
grid_s_sim[j+(i-1)*length(s2),] = c(s1[i],s2[j])
}
}
sum(grid_e_sim==grid_s_sim)
#beta_c intercept
beta_c_intercept_true = 8
#beta_c variable
beta_c_variable_true = 4
x11()
par(mfrow=c(1,2), mai = c(0.4, 0.4, 0.4, 0.4))
#beta_e variable
beta_e_variable_true = matrix(0,length(e1), length(e2))
beta_e_variable_true_col = matrix(0,length(e1)*length(e2),3)
for (i in 1:length(e1)){
for (j in 1:length(e2)){
#beta_e_variable_true[i,j] = -0.01*(s1[i]+0.5)^3 - 0.01*(s2[j]-0.5)^3 + 0.007*(s2[j]-2.5)^3+3.5
beta_e_variable_true[i,j] = +0.05*(e1[i]+1)^2 + 0.05*(e2[j])^2 + 1.5 + 0.1*(e1[i]-2)
beta_e_variable_true_col[j+(i-1)*length(e2),] = c(beta_e_variable_true[i,j],e1[i],e2[j])
}
}
persp3D(e1,e2,beta_e_variable_true, colvar = beta_e_variable_true,theta=20,
phi=20,axes= TRUE,scale=2, box=TRUE, nticks=5,
ticktype="detailed",
xlab="x",
ylab="y",
zlab="z",
zlim = c(0,5),
clim = c(0,5),
cex.main = 2,
expand = 0.6,
bty = "g",
#contour = list(col = "grey", side = c("zmin", "z")),
main=expression(paste(beta["1E"]))
)
x11()
par(mfrow=c(1,2), mai = c(0.4, 0.4, 0.4, 0.4))
#beta_e variable
beta_e_variable_true = matrix(0,length(e1), length(e2))
beta_e_variable_true_col = matrix(0,length(e1)*length(e2),3)
for (i in 1:length(e1)){
for (j in 1:length(e2)){
#beta_e_variable_true[i,j] = -0.01*(s1[i]+0.5)^3 - 0.01*(s2[j]-0.5)^3 + 0.007*(s2[j]-2.5)^3+3.5
beta_e_variable_true[i,j] = +0.05*(e1[i]+1)^2 + 0.05*(e2[j])^2 + 1.5 + 0.1*(e1[i]-2)
beta_e_variable_true_col[j+(i-1)*length(e2),] = c(beta_e_variable_true[i,j],e1[i],e2[j])
}
}
persp3D(e1,e2,beta_e_variable_true, colvar = beta_e_variable_true,theta=20,
phi=20,axes= TRUE,scale=2, box=TRUE, nticks=5,
ticktype="detailed",
xlab="x",
ylab="y",
zlab="z",
zlim = c(0,5),
clim = c(0,5),
cex.main = 2,
expand = 0.6,
bty = "g",
#contour = list(col = "grey", side = c("zmin", "z")),
main=expression(paste(beta["1E"]))
)
#beta_s variable
beta_s_variable_true = matrix(0,length(s1), length(s2))
beta_s_variable_true_col = matrix(0,length(s1)*length(s2),3)
for (i in 1:length(s1)){
for (j in 1:length(s2)){
#beta_s_variable_true[i,j] = -0.05*(s1[i]-1)^2 - 0.05*(s2[j])^2 + 4.5 - 0.1*(s1[i]+3)
beta_s_variable_true[i,j] = -0.01*(s1[i]+0.5)^3 - 0.01*(s2[j]-0.5)^3 + 0.007*(s2[j]-2.5)^3+3.5
beta_s_variable_true_col[j+(i-1)*length(s2),] = c(beta_s_variable_true[i,j],s1[i],s2[j])
}
}
persp3D(s1,s2,beta_s_variable_true, colvar = beta_s_variable_true,theta=20,
phi=20,axes= TRUE,scale=2, box=TRUE, nticks=5,
ticktype="detailed",
xlab="x",
ylab="y",
zlab="z",
zlim = c(0,5),
clim = c(0,5),
cex.main = 2,
expand = 0.6,
bty = "g",
#contour = list(col = "grey", side = c("zmin", "z")),
main=expression(paste(beta["1S"]))
)
set.seed(6494)
n = length(s1)^4
Xc_var = rnorm(n, 3, 5)
Xe_var = rnorm(n, -4, 5)
Xs_var = rnorm(n, 4, 5)
Xc = cbind(rep(1,n), Xc_var)
Xe = Xe_var
Xs = Xs_var
#create variance on four dimensional grid
epsilon = rnorm(n,0,2)
n = length(s1)^4 #create "four-dimensional grid"
f = 4
l = rep(list(x), f)
coords = expand.grid(l)
X_coords = cbind(Xc_var, Xe_var, Xs_var, coords, epsilon)
names(X_coords)[4:7]=c("E1", "E2", "S1", "S2")
#response y
beta_c_true = cbind(beta_c_intercept_true, beta_c_variable_true)
beta_s_true = beta_s_variable_true_col
beta_e_true = beta_e_variable_true_col
yc = rep(0,n)
for (i in 1:n){
coords_e = X_coords[i,4:5]
coords_s = X_coords[i,6:7]
yc[i] = Xc[i,]%*%t(beta_c_true) +
Xe_var[i]*beta_e_variable_true[coords_e[[1]]/step+adj,coords_e[[2]]/step+adj] +
Xs_var[i]*beta_s_variable_true[coords_s[[1]]/step+adj,coords_s[[2]]/step+adj] +
epsilon[i]
}
help(Norm)
